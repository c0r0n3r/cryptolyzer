#!/usr/bin/env python
# -*- coding: utf-8 -*-

import abc
import argparse
import cryptography
import uri
import sys

import socket

from crypton.common.algorithm import Authentication, MAC
from crypton.common.exception import NetworkError, NetworkErrorType

from crypton.tls.ciphersuite import TlsCipherSuite
from crypton.tls.extension import TlsExtensionType, TlsExtensionServerName, TlsExtensionEllipticCurves, TlsNamedCurve, TlsSignatureAndHashAlgorithm, TlsExtensionSignatureAlgorithms, TlsECPointFormat, TlsExtensionECPointFormats, TlsExtensionEllipticCurves, TlsExtensionSupportedVersions, TlsExtensionKeyShare, TlsExtensionKeyShareReserved, TlsKeyShareEntry
from crypton.tls.subprotocol import TlsCipherSuiteVector, TlsHandshakeType, TlsAlertDescription
from crypton.tls.version import SslVersion, TlsVersion, TlsProtocolVersionFinal, TlsProtocolVersionDraft

from crypton.tls.client import L7Client, TlsClientHandshake, TlsHandshakeClientHello, TlsHandshakeClientHelloAnyAlgorithm, TlsAlert
from crypton.tls.client import SslClientHandshake, SslHandshakeClientHello, SslHandshakeClientHelloAnyAlgorithm, SslError
from client import TlsHandshakeClientHelloBasic, TlsHandshakeClientHelloAuthenticationDSS, TlsHandshakeClientHelloAuthenticationRSA, TlsHandshakeClientHelloAuthenticationECDSA, TlsHandshakeClientHelloKeyExchangeECDHx

SUPPORTED_SCHEMES = {
    'tls': {
        'port': 443
    },
    'https': {
        'port': 443
    },
    'imap': {
        'port': 143
    },
    'pop': {
        'port': 110
    },
    'smtp': {
        'port': 587
    },
    'openvpn': {
        'port': 1194
    },
    'openvpntcp': {
        'port': 1194
    },
}


class ArgParseActionURI(argparse.Action):
    def _to_uri(self, value):
        if u'//' not in value:
            value = u'tls://' + value

        return uri.URI(value)

    def __call__(self, parser, namespace, values, option_string=None):
        uris = map(self._to_uri, values)
        supported_schemes = L7Client.get_supported_schemes()
        if any([uri.scheme.name not in supported_schemes for uri in uris]):
            raise argparse.ArgumentError(self, '{} protocol is not supported'.format(str(uri.scheme.name)))

        setattr(namespace, self.dest, uris)


def get_argument_parser():
    parser = argparse.ArgumentParser(prog='cryptonit')

    subparsers = parser.add_subparsers(dest='command')

    parser_versions = subparsers.add_parser('versions', help='Check which protocol versions supported by the server(s)')
    parser_versions.add_argument('uris', metavar='URI', nargs='+', action=ArgParseActionURI)

    parser_ciphers = subparsers.add_parser('ciphers', help='Check which cipher suites supported by the server(s)')
    parser_ciphers.add_argument('uris', metavar='URI', nargs='+', action=ArgParseActionURI)

    parser_curves = subparsers.add_parser('curves', help='Check which curve suites supported by the server(s)')
    parser_curves.add_argument('uris', metavar='URI', nargs='+', action=ArgParseActionURI)

    parser_curves = subparsers.add_parser('certificates', help='Check which certificate used by the server(s)')
    parser_curves.add_argument('uris', metavar='URI', nargs='+', action=ArgParseActionURI)

    parser_curves = subparsers.add_parser('sigalgos', help='Check which signature and hash algorithm combinations supported by the server(s)')
    parser_curves.add_argument('uris', metavar='URI', nargs='+', action=ArgParseActionURI)

    return parser


class PluginBase(object):
    def __init__(self, l7_client):
        self._l7_client = l7_client

    @abc.abstractmethod
    def do(self):
        raise NotImplementedError()


class SupportedCipherSuites(PluginBase):
    def do(self):
        accepted_cipher_suites = []
        remaining_cipher_suites = list(TlsCipherSuite)
        while True:
            print([accepted_cipher_suite.name for accepted_cipher_suite in accepted_cipher_suites])
            try:
                client_hello = TlsHandshakeClientHelloAnyAlgorithm(self._l7_client.host)
                client_hello.cipher_suites = TlsCipherSuiteVector(remaining_cipher_suites)
                client_hello.protocol_version = TlsProtocolVersionFinal(TlsVersion.TLS1_2)
           
                server_messages = self._l7_client.do_tls_handshake(client_hello, client_hello.protocol_version)
           
                server_cipher_suite = server_messages[TlsHandshakeType.SERVER_HELLO].cipher_suite
                print(server_cipher_suite.name)
                for index, cipher_suite in enumerate(remaining_cipher_suites):
                    if cipher_suite == server_cipher_suite:
                        del remaining_cipher_suites[index]
                        accepted_cipher_suites.append(cipher_suite)
                        break
            except TlsAlert as e:
                if e.description == TlsAlertDescription.HANDSHAKE_FAILURE:
                    return accepted_cipher_suites
                else:
                    raise e
            except NetworkError as e:
                if e.error == NetworkErrorType.NO_RESPONSE:
                    return accepted_cipher_suites


class SupportedVersions(PluginBase):
    def do(self):
        supported_protocols = []

        client_hello = TlsHandshakeClientHelloAnyAlgorithm(self._l7_client.host)
        client_hello.cipher_suites = TlsCipherSuiteVector(list(TlsCipherSuite))
        record_version = TlsProtocolVersionFinal(TlsVersion.TLS1_2)


        from cryptography.hazmat.backends import default_backend
        from cryptography.hazmat.primitives import hashes
        from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey
        from cryptography.hazmat.primitives.kdf.hkdf import HKDF
        # Generate a private key for use in the exchange.
        private_key = X25519PrivateKey.generate()
        # In a real handshake the peer_public_key will be received from the
        # other party. For this example we'll generate another private key and
        # get a public key from that. Note that in a DH handshake both peers
        # must agree on a common set of parameters.
        peer_public_key = X25519PrivateKey.generate().public_key()
        shared_key = private_key.exchange(peer_public_key)
        # Perform key derivation.
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'handshake data',
            backend=default_backend()
        ).derive(shared_key)


        client_hello.extensions.append(TlsExtensionKeyShareReserved([TlsKeyShareEntry(TlsNamedCurve.X25519, map(ord, derived_key))]))
        client_hello.extensions.append(TlsExtensionKeyShare([TlsKeyShareEntry(TlsNamedCurve.X25519, map(ord, derived_key))]))
        supported_versions = [TlsProtocolVersionDraft(draft_number) for draft_number in range(28, -1, -1)]

        while len(supported_versions) > 1:
            client_hello.extensions.append(TlsExtensionSupportedVersions(supported_versions))
            try:
                client_hello.protocol_version = record_version
                server_messages = self._l7_client.do_tls_handshake(client_hello, record_version, last_handshake_message_type=TlsHandshakeType.SERVER_HELLO)
            except TlsAlert as e:
                if e.description != TlsAlertDescription.PROTOCOL_VERSION:
                    raise e

                del supported_versions[0]
            except NetworkError as e:
                pass
            else:
                for extension in server_messages[TlsHandshakeType.SERVER_HELLO].extensions:
                    if extension.extension_type == TlsExtensionType.SUPPORTED_VERSIONS:
                        supported_protocols.append(extension.supported_versions[0])
                        break
                else:
                    server_hello = server_messages[TlsHandshakeType.SERVER_HELLO]
                    if server_hello.protocol_version > TlsProtocolVersionFinal(TlsVersion.TLS1_2):
                        supported_protocols.append(server_hello.protocol_version)
                break
            finally:
                del client_hello.extensions[-1]

        client_hello = TlsHandshakeClientHelloAnyAlgorithm(self._l7_client.host)
        for tls_version in TlsVersion:
            try:
                protocol_version = TlsProtocolVersionFinal(tls_version)
                client_hello.protocol_version = protocol_version
                server_messages = self._l7_client.do_tls_handshake(client_hello, protocol_version)
            except TlsAlert as e:
                if e.description not in [TlsAlertDescription.PROTOCOL_VERSION, TlsAlertDescription.HANDSHAKE_FAILURE]:
                    raise e
            except NetworkError as e:
                if e.error != NetworkErrorType.NO_RESPONSE:
                    raise e
            else:
                if server_messages[TlsHandshakeType.SERVER_HELLO].protocol_version == protocol_version:
                    supported_protocols.append(protocol_version)

        client_hello = SslHandshakeClientHelloAnyAlgorithm()
        try:
            server_messages = self._l7_client.do_ssl_handshake(client_hello)
        except SslError as e:
            if e.error != SslErrorType.NO_CIPHER_ERROR:
                raise e
        except NetworkError as e:
            pass
        else:
            supported_protocols.append(SslVersion.SSL2)

        return supported_protocols


class SupportedCurves(PluginBase):
    def do(self):
        client_hello = TlsHandshakeClientHelloKeyExchangeECDHx(self._l7_client.host)
        for index, extension in enumerate(client_hello.extensions):
            if extension.get_extension_type() == TlsExtensionType.SUPPORTED_GROUPS:
                del client_hello.extensions[index]
                break

        supported_curves = []
        for curve in TlsNamedCurve:
            try:
                client_hello.extensions.append(TlsExtensionEllipticCurves([curve, ]))
                server_messages = self._l7_client.do_tls_handshake(client_hello, client_hello.protocol_version)
            except TlsAlert as e:
                if e.description != TlsAlertDescription.HANDSHAKE_FAILURE:
                    raise e
            except NetworkError as e:
                if e.error != NetworkErrorType.NO_RESPONSE:
                    raise e
            else:
                supported_curves.append(curve)
            finally:
                del client_hello.extensions[-1]

        return supported_curves


class SupportedSignatureAndHashAlgorithms(PluginBase):
    def do(self):
        supported_algorithms = []
        for authentication in [Authentication.DSS, Authentication.RSA, Authentication.ECDSA]:
            cipher_suites = TlsCipherSuiteVector([
                cipher_suite
                for cipher_suite in TlsCipherSuite
                if (cipher_suite.value.key_exchange and cipher_suite.value.key_exchange.value.pfs and
                    cipher_suite.value.authentication and cipher_suite.value.authentication == authentication)
            ])

            for algorithm in TlsSignatureAndHashAlgorithm:
                if algorithm.value.signature_algorithm != authentication:
                    continue

                client_hello = TlsHandshakeClientHello(
                    cipher_suites=cipher_suites,
                    extensions=[
                        TlsExtensionServerName(self._l7_client.host),
                        TlsExtensionECPointFormats(list(TlsECPointFormat)),
                        TlsExtensionEllipticCurves(list(TlsNamedCurve)),
                        TlsExtensionSignatureAlgorithms([algorithm, ]),
                    ]
                )

                try:
                    server_messages = self._l7_client.do_tls_handshake(client_hello, client_hello.protocol_version, last_handshake_message_type=TlsHandshakeType.SERVER_HELLO)
                except TlsAlert as e:
                    if (e.description != TlsAlertDescription.HANDSHAKE_FAILURE and
                        e.description != TlsAlertDescription.ILLEGAL_PARAMETER):
                        raise e
                except NetworkError as e:
                    pass
                else:
                    supported_algorithms.append(algorithm)
                finally:
                    del client_hello.extensions[-1]

        return supported_algorithms


class UsedCertificates(PluginBase):
    def do(self):
        certificates = set()
        client_hello_messages = [
            TlsHandshakeClientHelloBasic(),
            TlsHandshakeClientHelloAuthenticationDSS(self._l7_client.host),
            TlsHandshakeClientHelloAuthenticationRSA(self._l7_client.host),
            TlsHandshakeClientHelloAuthenticationECDSA(self._l7_client.host),
        ]

        for client_hello in client_hello_messages:
            try:
                server_messages = self._l7_client.do_tls_handshake(client_hello, client_hello.protocol_version, TlsHandshakeType.CERTIFICATE)
            except TlsAlert as e:
                if e.description != TlsAlertDescription.HANDSHAKE_FAILURE:
                    raise e
            except NetworkError as e:
                if e.error != NetworkErrorType.NO_RESPONSE:
                    raise e
            else:
                certificates.add(server_messages[TlsHandshakeType.CERTIFICATE].certificate_chain[0])

        return certificates



if __name__ == '__main__':
    socket.setdefaulttimeout(1.0)

    argument_parser = get_argument_parser()
    arguments = argument_parser.parse_args()

    for uri in arguments.uris:
        l7_client = L7Client.from_scheme(
            uri.scheme.name,
            uri.host,
            int(uri.port) if uri.port else SUPPORTED_SCHEMES[uri.scheme.name]['port'],
        )

        if arguments.command == 'ciphers':
            supported_cipher_suites = SupportedCipherSuites(l7_client).do()
            print(50 * '-')
            print('\n'.join([cipher_suite.name for cipher_suite in supported_cipher_suites]))

        if arguments.command == 'versions':
            supported_protocol_version = SupportedVersions(l7_client).do()
            print(50 * '-')
            print('\n'.join([str(version) for version in sorted(supported_protocol_version)]))

        if arguments.command == 'curves':
            supported_curves = SupportedCurves(l7_client).do()
            print(50 * '-')
            print('\n'.join([str(curve) for curve in supported_curves]))

        if arguments.command == 'sigalgos':
            supported_sigalgos = SupportedSignatureAndHashAlgorithms(l7_client).do()
            print(50 * '-')
            print('\n'.join([str(curve) for curve in supported_sigalgos]))

        if arguments.command == 'certificates':
            certificates = UsedCertificates(l7_client).do()
            print(50 * '-')
            print('\n'.join([str(certificate._certificate.subject.get_attributes_for_oid(cryptography.x509.oid.NameOID.COMMON_NAME)) for certificate in certificates]))
            print('\n'.join([str(certificate._certificate.issuer.get_attributes_for_oid(cryptography.x509.oid.NameOID.COMMON_NAME)) for certificate in certificates]))
            print('\n'.join([str(certificate._certificate.public_key()) for certificate in certificates]))
